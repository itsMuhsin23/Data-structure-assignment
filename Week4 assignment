#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

struct Node* head = NULL;


struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}


void insertFront(int value) {
    struct Node* newNode = createNode(value);

    if (head == NULL) {
        head = newNode;
        return;
    }

    newNode->next = head;
    head->prev = newNode;
    head = newNode;
}

void insertEnd(int value) {
    struct Node* newNode = createNode(value);

    if (head == NULL) {
        head = newNode;
        return;
    }

    struct Node* temp = head;
    while (temp->next != NULL)
        temp = temp->next;

    temp->next = newNode;
    newNode->prev = temp;
}


void insertAtPos(int value, int pos) {
    struct Node* newNode = createNode(value);

    if (pos == 0) {               // Insert at front
        insertFront(value);
        return;
    }

    struct Node* temp = head;
    for (int i = 0; i < pos - 1 && temp != NULL; i++)
        temp = temp->next;

    if (temp == NULL) {
        printf("Position out of range!\n");
        return;
    }

    newNode->next = temp->next;
    newNode->prev = temp;

    if (temp->next != NULL)
        temp->next->prev = newNode;

    temp->next = newNode;
}


void traverse() {
    struct Node* temp = head;

    if (temp == NULL) {
        printf("List is empty.\n");
        return;
    }

    printf("Doubly Linked List: ");
    while (temp != NULL) {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
// RECURSIVE DELETE 
void deleteAll(struct Node* node) {
    if (node == NULL)
        return;

    deleteAll(node->next);  // recursively delete next
    free(node);
}


int main() {
    int choice, value, pos;

    while (1) {
        printf("\n----- DOUBLY LINKED LIST MENU -----\n");
        printf("1. Insert at Front\n");
        printf("2. Insert at End\n");
        printf("3. Insert at Position (Between Nodes)\n");
        printf("4. Traverse\n");
        printf("5. Delete All (Recursive)\n");
        printf("6. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value: ");
                scanf("%d", &value);
                insertFront(value);
                break;

            case 2:
                printf("Enter value: ");
                scanf("%d", &value);
                insertEnd(value);
                break;

            case 3:
                printf("Enter value & position: ");
                scanf("%d %d", &value, &pos);
                insertAtPos(value, pos);
                break;

            case 4:
                traverse();
                break;

            case 5:
                deleteAll(head);
                head = NULL;
                printf("All nodes deleted using recursion.\n");
                break;

            case 6:
                exit(0);

            default:
                printf("Invalid choice!\n");
        }
    }
return 0;
}

Difference between link list and circular linked list:

A linked list is a linear data structure in which each node points to the next node, and the last node points to NULL, indicating the end of the list. It has a definite beginning (head) and a definite end. Traversal automatically stops when the next pointer becomes NULL.

A circular linked list, on the other hand, is a variation in which the last node does not point to NULL. Instead, it points back to the first node, forming a loop. This means the list has no natural end, and traversal continues until you explicitly stop it. Because of this circular connection, care must be taken to avoid infinite looping.

Differnece in sorting algorithm:

When sorting a normal linked list, the algorithm can easily detect the end of the list because the last node points to NULL. This makes traversal simple, and sorting algorithms such as Bubble Sort, Insertion Sort, and Merge Sort can run without any special stopping conditions.

In a circular linked list, the last node does not point to NULL; instead, it points back to the head. Because of this, sorting algorithms must be written more carefully. The program must include conditions to stop traversal when the pointer returns to the head, otherwise the algorithm will enter an infinite loop.

Although the time complexities remain the same for both structures, the implementation becomes more complex in a circular linked list. Merge sort and bubble sort, for example, require extra checks to ensure the loop does not continue endlessly.



void bubbleSortNormal(struct Node* head) {
    int swapped;
    struct Node* ptr;

    if (head == NULL) return;

    do {
        swapped = 0;
        ptr = head;

        while (ptr->next != NULL) {  // stops at NULL
            if (ptr->data > ptr->next->data) {
                int temp = ptr->data;
                ptr->data = ptr->next->data;
                ptr->next->data = temp;
                swapped = 1;
            }
            ptr = ptr->next;
        }
    } while (swapped);
}


void bubbleSortCircular(struct Node* head) {
    if (head == NULL) return;

    int swapped;
    struct Node* ptr;

    do {
        swapped = 0;
        ptr = head;

        do {
            struct Node* nextNode = ptr->next;

            // stop comparing when nextNode is head (end of one loop)
            if (nextNode == head) 
                break;

            if (ptr->data > nextNode->data) {
                int temp = ptr->data;
                ptr->data = nextNode->data;
                nextNode->data = temp;
                swapped = 1;
            }

            ptr = ptr->next;

        } while (ptr != head);   // stop when a full loop is done

    } while (swapped);
}

